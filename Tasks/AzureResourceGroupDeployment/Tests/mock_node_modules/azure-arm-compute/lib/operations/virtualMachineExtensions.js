'use strict';
var util = require('util');
function VirtualMachineExtensions(client) {
    this.client = client;
}
VirtualMachineExtensions.prototype.get = (resourceGroupName, vmName, extensionName, options, callback) => {
    console.log("virtualMachineExtensions.get is called on vm %s", vmName);

    var client = this.client;
    if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
    }
    if (!callback) {
        throw new Error('callback cannot be null.');
    }
    var expand = (options && options.expand !== undefined) ? options.expand : undefined;
    var apiVersion = '2016-03-30';

    var fileUris = [
        "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vm-winrm-windows/ConfigureWinRM.ps1",
        "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vm-winrm-windows/makecert.exe",
        "https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vm-winrm-windows/winrmconf.cmd"];
    var result = {
        properties: {
            "settings":
            {
                "fileUris": fileUris
            },
            "provisioningState": "Succeeded"
        }
    };
    if (resourceGroupName.includes("ExtensionNotPresent")) {
        return callback("Not found", null);
    }
    else if (resourceGroupName.includes("ExtensionPresent")) {
        if (resourceGroupName.includes("ProvisioningStateIsNotSucceeded")) {
            result["properties"]["provisioningState"] = "Failed";
        }
        if (resourceGroupName.includes("WinRMHttpsListenerNotEnabled")) {
            result["properties"]["settings"]["fileUris"] = ["https://something.com/something.ps1"];
        }
    }
    return callback(null, result);
};
VirtualMachineExtensions.prototype.createOrUpdate = (resourceGroupName, vmName, extensionName, parameters, options, callback) => {
    console.log("virtualMachineExtensions.createOrUpdate is called");
    var client = this.client;
    if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
    }
    if (!callback) {
        throw new Error('callback cannot be null.');
    }

    console.log("virtualMachineExtensions.createOrUpdate is called");
    var result = {
        properties: {
            "provisioningState": "Succeeded"
        }
    };
    if (resourceGroupName.includes("ProvisioningOfExtensionFailed")) {
        result["properties"]["provisioningState"] = "Failed";
    }
    if (resourceGroupName.includes("ProvisioningOfDeploymentGroupExtensionFailed")) {
        result["properties"]["provisioningState"] = "Failed";
        return callback(result)
    }
    if (resourceGroupName.includes("IncorrectPat")) {
        result["properties"]["provisioningState"] = "Failed";
        return callback(result)
    }
    return callback(null, result);
};
VirtualMachineExtensions.prototype.deleteMethod = (resourceGroupName, vmName, extensionName, callback) => {
    console.log("virtualMachineExtensions.deleteMethod is called");
    var client = this.client;
    if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
    }
    if (!callback) {
        throw new Error('callback cannot be null.');
    }
    if (resourceGroupName.includes("StoppedVM")) {
        return callback("Could not delete extension from stopped vm");
    }
    console.log("Successfully removed the extension from the vm %s", vmName);
    return callback(null, "Successfully removed the extension");
};
module.exports = VirtualMachineExtensions;
